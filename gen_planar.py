# -*- coding: utf-8 -*-
"""opencv-python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14hCN4LonxeHaBFLTzGgV563heghqWaKF
"""

import os
import cv2
from PIL import Image
import numpy as np
from skimage.measure import label

def rename(root_dir):
  file_list = os.listdir(root_dir)
  for name in file_list:
    new_name = name.split('_')[-1]
    print(new_name)
    os.rename(os.path.join(root_dir,name),os.path.join(root_dir,new_name))

def create_my_cityscpaes_label_colormap():
  colormap=np.zeros([19,3],dtype=int)
  colormap[0]=np.array([ 0,0, 0])
  colormap[1]=np.array([ 128, 0 ,0])
  colormap[2]=np.array([ 64, 0, 0])
  colormap[3]=np.array([ 128 ,128, 0])
  colormap[4]=np.array([ 0, 0, 128])
  colormap[5]=np.array([ 128, 0, 128])
  colormap[6]=np.array([ 0, 128, 128])
  colormap[7]=np.array([ 128, 128, 128])
  colormap[8]=np.array([0, 128, 0])
  colormap[9]=np.array([ 192, 0, 0])
  colormap[10]=np.array([135,206,235])
  colormap[11]=np.array([ 192, 128, 0])
  colormap[12]=np.array([ 64, 0, 128])
  colormap[13]=np.array([ 192, 0, 128])
  colormap[14]=np.array([ 64, 128, 128])
  colormap[15]=np.array([ 192, 128, 128])
  colormap[16]=np.array([ 0, 64, 0])
  colormap[17]=np.array([ 128, 64, 0])
  colormap[18]=np.array([ 255, 255, 0])
  return colormap

def gen_planar(root_dir):
  colormap = create_my_cityscpaes_label_colormap()
  file_list = os.listdir(root_dir)
  print(file_list)
  for file_name in file_list:
    if os.path.splitext(file_name)[-1] == ".bmp":
      file_name = os.path.join(root_dir,file_name)
      img = cv2.imread(file_name)
      print(file_name)
      height,width=img.shape[0],img.shape[1]
      # BGR -> RGB
      img = img[: , : , : : -1]
      temp_img = np.zeros((height,width,3), np.uint8)
      for i in range(height):
        for j in range(width):
          temp_img[i,j]=(255,255,255)
      base_dir = os.path.splitext(file_name)[0]
      print("base_dir %s " % base_dir)
      try:
        os.mkdir(base_dir)
      except:
        pass
      for idx, color in enumerate(colormap):
        temp_list = []
        for i in range(height):
          for j in range(width):
            if (img[i,j] == color).all():
              temp_img[i,j]=color
              temp_list.append((i,j))
        output_file_name = os.path.join(base_dir, str(idx))
        output_file_name += '.bmp'
        r = Image.fromarray(temp_img.astype(np.uint8),'RGB')
        if len(temp_list) > 0:
          r.save(output_file_name)
          get_lcc(base_dir,output_file_name,idx,color)
        for i in range(height):
          for j in range(width):
            temp_img[i,j]=(255,255,255)

def largestConnectComponent(bw_img):
    '''
    compute largest Connect component of a binary image
    
    Parameters:
    ---

    bw_img: ndarray
        binary image
	
    Returns:
    ---

    lcc: ndarray
		largest connect component.

    Example:
    ---
        >>> lcc = largestConnectComponent(bw_img)

    '''
    labeled_img = label(bw_img)
    # print(labeled_img)
    lcc = labeled_img == np.argmax(np.bincount(labeled_img.flat))
    return lcc

def get_lcc(root_dir, test_lcc_img_name, color_label, color):
  test_lcc_img = cv2.imread(test_lcc_img_name)
  print("get_lcc input : %s" % test_lcc_img_name)
  gray_image = cv2.cvtColor(test_lcc_img, cv2.COLOR_RGB2GRAY)
  _, thresh = cv2.threshold(gray_image, 125, 255, cv2.THRESH_BINARY_INV)
  nncomps = cv2.connectedComponentsWithStats(thresh)
  labels = nncomps[1]
  centroid = nncomps[3]
  status = nncomps[2]
  # for line in labels:
  #   print(line)
  print(status)
  for rec in status:
    x = rec[0]
    y = rec[1]
    width = rec[2]
    height = rec[3]
    cv2.rectangle(test_lcc_img, (x,y), (x+width, y+height), (125,125,125), 2)
  instances = len(status) -1 
  print(instances)
  # 创建一个临时图
  height,width=test_lcc_img.shape[0],test_lcc_img.shape[1]
  temp_img = np.zeros((height,width,3), np.uint8)
  for ins in range(1, instances + 1):
    if status[ins][2] < 5 or status[ins][3] < 5:
      continue
    for i in range(height):
      for j in range(width):
        temp_img[i,j]=(255,255,255)
        if labels[i][j] == ins:
          temp_img[i][j] = color
          # print("get_lcc color: %s " % color)
    postfix = str(color_label) + '_' + str(ins) + '.bmp'
    output_file_name = os.path.join(root_dir, postfix)
    r = Image.fromarray(temp_img.astype(np.uint8),'RGB')
    r.save(output_file_name)
    temp_img = np.zeros((height,width,3), np.uint8)


  # cv2.imshow('thresh', thresh)
  # cv2.imshow('org',test_lcc_img)
  # cv2.waitKey(0)
  return labels, status

if __name__ == "__main__":

  """get planar"""
  root_dir = 'background\\output'
  gen_planar(root_dir)

  # file_list = os.listdir(root_dir)
  # rename(root_dir)

  test_lcc_img_name = 'background\\output\\000\\8.bmp'
  
  # get_lcc(root_dir, test_lcc_img_name)
  """test lcc1"""
  # print(type(test_lcc_img))
  # lcc = largestConnectComponent(test_lcc_img)
  # cv2.imshow('lcc', lcc)
  # test_lcc_img = test_lcc_img * lcc
  # print(type(lcc), lcc.shape,lcc[0])
  # cv2.imshow('lcc', test_lcc_img)
  
  """test lcc2"""
  # test_lcc_img = cv2.imread(test_lcc_img_name)
  # gray_image = cv2.cvtColor(test_lcc_img, cv2.COLOR_RGB2GRAY)
  # _, thresh = cv2.threshold(gray_image, 125, 255, cv2.THRESH_BINARY_INV)
  # nncomps = cv2.connectedComponentsWithStats(thresh)
  # labels = nncomps[1]
  # centroid = nncomps[3]
  # status = nncomps[2]
  # # for line in labels:
  # #   print(line)
  # print(status)
  # for rec in status:
  #   x = rec[0]
  #   y = rec[1]
  #   width = rec[2]
  #   height = rec[3]
  #   cv2.rectangle(test_lcc_img, (x,y), (x+width, y+height), (125,125,125), 2)
  # instances = len(status) -1 
  # cv2.imshow('thresh', thresh)
  # cv2.imshow('org',test_lcc_img)
  # cv2.waitKey(0)